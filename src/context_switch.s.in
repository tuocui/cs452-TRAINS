.file	"context_switch.c"
.text

.align 2
.global init_kernelentry
.type init_kernelentry, %function
init_kernelentry:
  mov ip, sp
  stmfd sp!, {fp, ip, lr}
  ldr r1, =kernelentry
  add r1, r1, #0x218000 
  mov r2, #0x28
  str r1, [r2]
  ldmfd sp, {fp, sp, pc}

.align 2
.global print_pc	
.type	print_pc, %function
print_pc:
  mov ip, sp
  stmfd sp!, {fp, ip, lr}
  mov r0, #1
  mov r1, sp
  bl bwputr
  ldmfd sp, {fp, sp, pc}



.align 2
.global kernel_exit
.type kernel_exit, %function
@TODO: find out args etc settings

kernel_exit:
  @ 1. push kregs onto stack
  mov ip, sp
  stmfd sp!, {r3-r12, r14}
  @ 2. switch to system mode
  msr cpsr_c, #0xdf
  @ 3. get retval, sp, spsr from TD
  mov sp, r1
  msr spsr, r2
  @ load the pc into r1
  ldmfd sp!, {r1}
  @ r0 is already retval
  @ 4. pop the registers of the active task 
  ldmfd sp!, {r4-r12, r14}
  @ 6. return to svc state
  msr cpsr_c, #0xd3
  @ 7. install spsr in cpsr, now in user mode
  msr cpsr_c, r2
  @ 8. install the pc of the active task
  movs pc, r1
  @ldmfd sp, {r3-r12, pc}


@.align 2
@.global kernel_entry
@.type kernel_entry, %function
kernelentry:
  @ 3. change to system state, sp lr are in user
  msr cpsr_c, #0xdf
  @mov r0, #1
  @mov r1, pc
  @bl bwputr
  @ 5. store user's registers values onto user stack
  stmfd sp!, {r4-r12, r14}
  @ 6. save active user task's sp in r1
  mov r1, sp
  @ 7. back to service state
  msr cpsr_c, #0xd3
  @ save user's pc to stack which is stored in lr_svc
  stmfd r1!, {r14}
  @mov r0, #1
  @mov r1, r3
  @bl bwputr
  @ 8. getting spsr, user's values were set by swi
  mrs r2, spsr
  @ 9. pop kernel registers from stack
  ldmfd sp!, {r3-r12, r14}
  mov sp, ip
  movs pc, lr
  @ r1: user sp, r2: user spsr, arguments on user stack
  @ request type is r1 - 4, figure out #params from there


